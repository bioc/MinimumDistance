<<which.CHR>>=
CHR <- 1
@

<<which.wga>>=
which.wga <- grep("WGA", lrSet$DNA.Source)
@

Remove \Sexpr{length(which.wga)} whole genome amplified samples.
Working on one chromosome at a time allows working with matrices
rather than \Robject{ffdf} objects.

<<matrixObject>>=
which.markers <- which(chromosome(lrSet) == CHR)
invisible(open(logR(lrSet)))
sample.index <- (1:ncol(lrSet))[-which.wga]
fff <- function(x, i, j) x[i, j]
lset <- checkExists("lset", .path=outdir, .FUN=fff,  x=lrSet, i=which.markers, j=sample.index)
invisible(close(logR(lrSet)))
logR(lset) <- as.matrix(logR(lset))
@



The results from the segmentation analysis were saved as $rD<strata>$,
where strata refers to the index of the R batch job.  The function
\Rfunction{getSegMeanRanges} loops through the stratum index, loading
the \Robject{RangedData} object.

<<RangedData>>=
segmean_ranges <- getSegMeans(outdir, CHR=CHR)
segmeans <- excludeRanges(segmean_ranges, lrSet)
@

<<triosUsed, eval=FALSE>>=
ids <- lapply(split(segmeans$id, segmeans$family), unique)
ix <- match(unlist(ids), sampleNames(lset))
beaty_samples <- cbind(sampleNames(lset)[ix], lset$sampleNames[ix])
colnames(beaty_samples) <- c("IDATprefix", "Sample.ID")
write.csv(beaty_samples, "beaty_samples.csv", quote=FALSE, row.names=FALSE)
@
