<<>>=
library(Beaty)
ldPath(beadstudiodir())
##data(deletion.ranges)
##data(amp.ranges)
##data(deletion.ranges_test)
##data(amp.ranges_test)
##data(minDistanceRanges)
##data(minDistanceSet)
##data(maxDistanceRanges)
##data(maxDistanceSet)
data(bsSet)
srcdir <- "~/projects2/BeatyExperimentData/data"
load(file.path(srcdir, "minDistanceRanges.rda"))
load(file.path(srcdir, "deletion.ranges_test.rda"))
load(file.path(srcdir, "minDistanceSet.rda"))
##featureData(maxDistanceSet) <- featureData(minDistanceSet) <- featureData(bsSet)
data(rf); data(cnv)
ranges.all <- combineRanges(deletion.ranges, amp.ranges)
data(penn.joint)
@

<<data>>=
ranges.all <- combineRanges(deletion.ranges, amp.ranges)
palette <- brewer.pal(9, "Set1")[1:3]
dist.df <- data.frame.for.rectangles(ranges.all, palette=palette)
penn.denovo <- getPennDenovo(penn.joint)
penn.denovo <- penn.denovo[penn.denovo$num.mark >= 3, ]
penn.df <- data.frame.for.rectangles(penn.denovo, palette)
combined.df <- combine.data.frames(dist.df, penn.df)
@

This is a ROUGH estimate of discordance.  Better approach would be to
use findOverlaps.

<<disc>>=
pks <- findPeaks(ranges.all)
chr.index <- split(1:nrow(pks), pks$chrom)
xlimList <- lapply(chr.index, function(i, rd, FRAME=250e3){
	rd.chr <- rd[i, ]
	rd.chr <- rd.chr[order(rd.chr$freq, decreasing=TRUE), ]
	rd.chr <- rd.chr[1, ]
	c(min(start(rd.chr))-FRAME, max(end(rd.chr))+FRAME)
}, rd=pks)
xlimit <- do.call(rbind, xlimList)
combined.df <- combine.data.frames(dist.df, penn.df)
disc.fig <- vector("list", 22)
conc.fig <- vector("list", 22)
mykey <- simpleKey(c("homo-del", "hemi-del", "amp"), points=FALSE,
		   rectangles=TRUE, col=palette[1:3], space="top")
mykey$rectangles$col <- palette
mykey$rectangles$border <- palette
for(CHR in 1:22){
	xlim <- xlimit[CHR, ]
	dist <- rangesInXlim(ranges.all, CHR=CHR, xlim)
	penn <- rangesInXlim(penn.denovo, CHR=CHR, xlim)
##	notInPenn <- dist$id[!dist$id %in% penn$id]
##	notInDist <- penn$id[!penn$id %in% dist$id]
	dist.df <- data.frame.for.rectangles(dist[!dist$id %in% penn$id, ], palette=palette)
##	trace(data.frame.for.rectangles, browser)
	penn.df <- data.frame.for.rectangles(penn[!penn$id %in% dist$id, ], palette=palette)
	combined.chr <- combine.data.frames(dist.df, penn.df)
	disc.fig[[CHR]] <- xyplot(id~midpoint|method+chr, data=combined.chr,
				  prepanel=prepanel.fxn,
				  panel=my.rectangle,
				  x0=combined.chr$x0,
				  x1=combined.chr$x1,
				  y0=combined.chr$y0,
				  y1=combined.chr$y1,
				  col=combined.chr$col,
				  border=combined.chr$col,
				  alpha=1,
				  chr.size=combined.chr$chr.size,
				  scales=list(y="free", x="same", rot=0, tick.number=10),
				  coverage=combined.chr$coverage, xlab="Mb", ylab="offspring id",
				  show.coverage=FALSE, key=mykey,
				  par.strip.text=list(lines=0.7, cex=0.6),
				  layout=c(1, 2),
				  min=combined.chr$min, max=combined.chr$max,
				  chr=combined.chr$chr,
				  plot.cytoband=TRUE, xlim=xlim/1e6)

xyplot(id~midpoint, data=combined.chr,
				  panel=my.rectangle,
				  x0=combined.chr$x0,
				  x1=combined.chr$x1,
				  y0=combined.chr$y0,
				  y1=combined.chr$y1,
				  col=combined.chr$col,
				  border=combined.chr$col,
				  alpha=1,
				  chr.size=combined.chr$chr.size,
				  scales=list(y="free", x="same", rot=0, tick.number=10),
				  coverage=combined.chr$coverage, xlab="Mb", ylab="offspring id",
				  show.coverage=FALSE, key=mykey,
				  par.strip.text=list(lines=0.7, cex=0.6),
				  layout=c(1, 2),
				  min=combined.chr$min, max=combined.chr$max,
				  chr=combined.chr$chr,
				  plot.cytoband=TRUE, xlim=xlim/1e6)

##	inPenn <- dist$id[dist$id %in% penn$id]
##	inDist <- penn$id[penn$id %in% dist$id]
##	ids <- intersect(inPenn, inDist)
##	if(length(ids)==0) next()
##	##plot only the discordant samples
##	combined.chr <- combined.df[combined.df$chr == CHR & combined.df$id %in% ids, ]
##	combined.chr$id <- factor(combined.chr$id)
##	conc.fig[[CHR]] <- xyplot(id~midpoint|method+chr, data=combined.chr, panel=my.rectangle,
##				  x0=combined.chr$x0,
##				  x1=combined.chr$x1,
##				  y0=combined.chr$y0,
##				  y1=combined.chr$y1,
##				  col=combined.chr$col,
##				  border=combined.chr$col,
##				  alpha=1,
##				  chr.size=combined.chr$chr.size,
##				  scales=list(y="free", x="same", rot=0, tick.number=10),
##				  coverage=combined.chr$coverage, xlab="Mb", ylab="offspring id",
##				  show.coverage=FALSE,
##				  key=mykey,
##				  par.strip.text=list(lines=0.7, cex=0.6),
##				  layout=c(1, 2),
##				  min=combined.chr$min, max=combined.chr$max,
##				  chr=combined.chr$chr,
##				  plot.cytoband=TRUE, xlim=xlim/1e6)
}
@


<<>>=
trellis.device(device="pdf", file="figures/discordance_%02d.pdf",
	       width=8, height=6,
	       onefile=FALSE)
pars <- trellis.par.get()
pars$axis.text$cex <- 0.3
pars$xlab.text$cex <- 0.8
trellis.par.set("axis.text", pars$axis.text)
trellis.par.set("axis.text", pars$xlab.text)
for(i in 1:22) print(disc.fig[[i]])
dev.off()

trellis.device(device="pdf", file="figures/concordance_%02d.pdf",
	       width=8, height=6,
	       onefile=FALSE)
pars <- trellis.par.get()
pars$axis.text$cex <- 0.6
pars$xlab.text$cex <- 0.8
trellis.par.set("axis.text", pars$axis.text)
trellis.par.set("axis.text", pars$xlab.text)
for(i in 1:22) print(conc.fig[[i]])
dev.off()
stop()
@

Plot the data for ranges inferred by distance but not by PennCNV:

<<>>=
##xlim <- xlimList[[4]]; xlim[1] <- 69.15
xlim <- xlimit[4, ]
##trace(onlyInOne, browser)
distOnly <- onlyInOne(ranges.all, penn.denovo, CHR=4, xlim=xlim, method='d')
pennOnly <- onlyInOne(ranges.all, penn.denovo, CHR=4, xlim=xlim, method='p')
data(bsSet)
trioList <- initTrioList(bsSet, minDistanceSet)
df <- constructTrioSetFrom(ranged.data=tmp[1, ], trioList=trioList, FRAME=200e3)
df$logR <- ifelse(df$logR < -2.8, jitter(-2.8, amount=0.1), df$logR)
##distOnly$seg.mean[distOnly$seg.mean < -2.5] <- -2.5
trace(logrpanelfunction2, browser)
plot.logr <- xyplot(logR ~ x | subject, df,
		    panel=logrpanelfunction2,
		    layout=c(1,4),
		    index.cond=list(4:1),
		    xlab="Mb",
		    ylab="",
		    fill="lightblue",
		    alpha=1,
		    border="grey60",
		    ##ranges=tmp[1,],
		    ylim=c(-3,2),
		    highlight=T)

			    highlight.fill=highlight.fill,
			    highlight.border=highlight.border,
			    highlight.alpha=highlight.alpha,
			    ranges=ranges,
			    panel=logrpanelfunction,
			    highlight=highlight,
			    ylim=ylim,
			    ...)

		if(exists("cbs.segs")){
			if(CHR != unique(cbs.segs$chrom))
				load(file.path(beadstudiodir(), paste("cbs_chr" , CHR, ".rda", sep="")))
		} else 	load(file.path(beadstudiodir(), paste("cbs_chr" , CHR, ".rda", sep="")))
cbs.segs <- minDistanceRanges[minDistanceRanges$chrom==
		addSegments(cbs.segs=cbs.segs,
			    distanceRanges=distanceRanges,
			    ranges.object=ranges.object[i, ],
			    col=highlight.border,
			    bg=highlight.fill,
			    CHR=CHR, mset=mset,
			    highlight=highlight, ...)


## focus on the blue stripe just to the right of the more common alteration, as well as the one big deletion
trellis.device(device="pdf", file="figures/penn_chr4_fp_%02d.pdf",
	       width=8, height=6,
	       onefile=FALSE)
pars <- trellis.par.get()
pars$axis.text$cex <- 0.6
pars$xlab.text$cex <- 0.8
trellis.par.set("axis.text", pars$axis.text)
trellis.par.set("axis.text", pars$xlab.text)
## add arrows to indicate where the taqman probes would hit
lowlevel.xy(distanceRanges=pennOnly,
	    distanceSet=minDistanceSet,
	    bsSet=bsSet,
	    rf=rf,
	    cnv=cnv,
	    xlim=xlim)

lowlevel.xy <- function(distanceRanges, distanceSet,
			bsSet, rf, cnv,
			xlim, FRAME=500e3/1e6){
	for(i in 1:nrow(distanceRanges)){
		x <- distanceRanges[i, ]
		xlim <- c(start(x)[i]/1e6 - FRAME,
			  end(x)[i]/1e6 + FRAME)
		xlim[1] <- max(xlim[1], 0)
		grid.newpage()
		grid.trio2(ranges.object=x[i, ],
			   distanceRanges=distanceRanges,
			   distanceSet=distanceSet,
			   bsSet=bsSet,
			   xlimit=xlim,
			   CHR=x$chrom[i],
			   rf=rf,
			   cnv=cnv,
			   cex.genes=0.5,
			   par.strip.text=list(lines=0.7, cex=0.6),
			   highlight=TRUE,
			   cex=0.5, ...)
	}
}


FRAME <- 500e3/1e6
for(i in 1:nrow(x)){
	xlim <- c(start(x)[i]/1e6 - FRAME,
		  end(x)[i]/1e6 + FRAME)
	xlim[1] <- max(xlim[1], 0)
	if(x$state[i] %in% del.states){
		distanceRanges <- minDistanceRanges
		distanceSet <- minDistanceSet
	} else {
		distanceRanges <- maxDistanceRanges
		distanceSet <- maxDistanceSet
	}
	grid.newpage()
	grid.trio2(ranges.object=x[i, ],
				   distanceRanges=distanceRanges,
				   distanceSet=distanceSet,
				   bsSet=bsSet,
				   xlimit=xlim,
				   ylim=c(-3,2),
				   CHR=x$chrom[i],
				   rf=rf,
				   cnv=cnv,
				   cex.genes=0.5,
				   par.strip.text=list(lines=0.7, cex=0.6),
				   highlight=TRUE,
				   cex=0.5)
}
dev.off()


## the amplifications not in penncnv are generally false positives.  The rule for calling amplification should be a little /Users/rscharpf/projects2/Beaty/inst/scripts/tougher.
trellis.device(device="pdf", file="figures/chr4_distance_falseNegatives%02d.pdf",
	       width=8, height=6,
	       onefile=FALSE)
pars <- trellis.par.get()
pars$axis.text$cex <- 0.6
pars$xlab.text$cex <- 0.8
trellis.par.set("axis.text", pars$axis.text)
trellis.par.set("axis.text", pars$xlab.text)
for(i in 1:nrow(x)){
	xlim <- c(start(x)[i]/1e6 - FRAME,
		  end(x)[i]/1e6 + FRAME)
	xlim[1] <- max(xlim[1], 0)
	##xlim <- c(40, 43)
	##trace(grid.trioBaf, browser)
	grid.newpage()
##	trace(grid.trioLogR, browser)
##	trace(grid.trio2, browser)
##	trace(constructTrioSetFromRanges, browser)
	if(x$state[i] %in% del.states){
		distanceRanges <- minDistanceRanges
		distanceSet <- minDistanceSet
	} else {
		distanceRanges <- maxDistanceRanges
		distanceSet <- maxDistanceSet
	}
	##trace(grid.trio2, browser)
	grid.trio2(ranges.object=x[i, ],
		   distanceRanges=distanceRanges,
		   distanceSet=distanceSet,
		   bsSet=bsSet,
		   xlimit=xlim,
		   ylim=c(-3,2),
		   CHR=x$chrom[i],
		   rf=rf,
		   cnv=cnv,
		   cex.genes=0.5,
		   par.strip.text=list(lines=0.7, cex=0.6),
		   highlight=TRUE,
		   ##other.ranges=taq.ir,
		   cex=0.5)
}
dev.off()

@


For the vertical stripes, tabulate the following 3 x 3 table:
               denovo del P  normal P denovo amp P
denovo del D
normal D
denovo amp D

1.  Define a function that plots the frequencies of denovo events for
each chromosome.  Extract the chromosomes and loci with hotspots.  Do
this for both penncnv and distance.



<<frequency>>=
for(CHR in 1:22){
	rd <- ranges.all[ranges.all$chrom == CHR, ]
	ir <- IRanges(start(rd), end(rd))
	djr <- disjointRanges(rd)
	## count overlaps
	freq <- countOverlaps(query=djr, subject=ir)
}
## plot the disjoint Ranges at the bottom
##dist.df <- data.frame.for.rectangles(ranges.all, palette=palette)
##dist.djr <- data.frame.for.rectangles(djr, palette=palette)
@


2.  For hotspot that are identified by both, calculate the above 3 x 3
matrix.   There are 2 types of discordance:

- found by distance, but not by penncnv

- found by penncnv, but not by distance

Plot the lower level data and see whether penncnv has many false
positives, or whether the distance approach may be too conservative.

3.  Plot regions that appear to be false positives in PennCNV.


