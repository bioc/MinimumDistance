<<eval=FALSE>>=
bsSet <- checkExists("bsSet", .path=outdir, .FUN=load)
invisible(open(logR(bsSet)))
invisible(open(baf(bsSet)))
load(file.path(outdir, "disjointRangesList.rda"))
gr <- do.call("c", disjointRangesList)
offspring.rule <- function(MAD) ifelse(-1.5*MAD < log(1.5/2), -1.5*MAD, log(1.5/2))
parent.rule <- function()  log(1.8/2)
table(seqnames(gr))
@

<<sizeVfreq, eval=FALSE>>=
gr <- gr[elementMetadata(gr)[, "freq"] > 0, ]
freq <- elementMetadata(gr)[, "freq"]
w <- width(gr)
fact <- rep(NA, length(w))
fact[w < 1e3] <- 1
fact[w >= 1e3 & w< 10e3] <- 2
fact[w >= 10e3 & w < 50e3] <- 3
fact[w >= 50e3] <- 4
freq.split <- split(freq, fact)
pdf("try1figs/sizeVfreq.pdf")
par(las=1)
boxplot(freq.split, col="lightblue", xaxt="n", pch=21, cex=0.7)
axis(1, at=1:4, labels=c("< 1kb", "[1kb, 10kb)",
		"[10kb, 50kb)", "> 50kb"), cex.axis=0.8)
dev.off()
@

<<selectRange, eval=FALSE>>=
nmark <- elementMetadata(gr)[, "nmarkers"]
freq <- elementMetadata(gr)[, "freq"]
(II <- which(freq > 10 & nmark > 15))
gr[II, ]
##(index <- which(freq > 2 & nmark > 15))
@

Some of the biggest deletions may be singletons with a small number of
markers.

<<lowerleveldata,echo=FALSE, eval=FALSE>>=
load.it <- ifelse(c(1, diff(chromosome(gr))) == 1, TRUE, FALSE)
gr <- gr[elementMetadata(gr)[, "freq"] > 0, ]
samples <- elementMetadata(gr)[, "denovoSamples"]
samples.list <- split(elementMetadata(gr)[, "denovoSamples"], chromosome(gr))
samples.list <- lapply(samples.list, function(x) paste(x, collapse=","))
samples.list <- lapply(samples.list, function(x) unique(as.integer(strsplit(x, ",")[[1]])))
names(samples.list) <- paste("chr", 1:22, sep="")
FRAME <- 1e6
dir.create("try1figs", showWarnings=F)
(II <- which(elementMetadata(gr)[, "freq"] > 10 & elementMetadata(gr)[, "nmarkers"] > 15))
bitmap("try1figs/denovo%02d.png", width=8, height=7, res=400)
for(range.index in II){
	CHR <- chromosome(gr)[range.index]
	if(load.it[range.index]){
		i <- which(chromosome(bsSet) == CHR)
		denovo.families <- substr(sampleNames(bsSet)[samples.list[[CHR]]], 1, 5)
		all.families <- substr(sampleNames(bsSet), 1, 5)
		j <- which(all.families %in% denovo.families)
		chrset <- new("LogRatioSet",
			      logRRatio=as.matrix(logR(bsSet)[i, j]),
			      BAF=as.matrix(baf(bsSet)[i, j]),
			      featureData=featureData(bsSet)[i, ],
			      phenoData=phenoData(bsSet)[j, ],
			      annotation=annotation(bsSet))
		segmean_ranges <- getSegMeans(outdir, CHR=CHR)
		segmean_ranges <- segmean_ranges[substr(segmean_ranges$id, 1, 5) %in% denovo.families, ]
	}
	i <- featuresInRange(chrset, gr[range.index, ], FRAME=FRAME)
	sns <- triosInRange(bsSet, gr[range.index, ])
	sns.list <- split(sns, substr(sns, 1, 5))
	for(k in seq_along(sns.list)){

		ids <- sns.list[[k]]
		j <- match(ids, sampleNames(chrset))
		lset <- chrset[i, j]
		segmentation <- segmean_ranges[segmean_ranges$id %in% sampleNames(chrset)[j], ]
		layout(matrix(1:6, 6,1), heights=c(1, 1, 1, 1, 1, 1, 0.25))
		par(mar=c(0.5, 0.5, 0.5, 0.5), las=1, oma=c(4, 4, 4, 4))
		father.name <- ids[who(ids) == "father"]
		mother.name <- ids[who(ids) == "mother"]
		offspring.name <- ids[who(ids) == "offspring"]
		plotRange(father.name, segmentation, lset, range=gr[range.index, ],
			  THR=log(1.8/2), ylim=c(-1.5, 0.5),
			  pch=21, col="grey60", cex=0.6,
			  xaxt="n")
		plotRange(mother.name, segmentation, lset, range=gr[range.index, ],
			  THR=log(1.8/2), ylim=c(-1.5,0.5),
			  pch=21, col="grey60", cex=0.6,
			  xaxt="n")
		THR <- offspring.rule(lset$MAD[match(offspring.name, sampleNames(lset))])
		plotRange(offspring.name, segmentation, lset, range=gr[range.index, ],
			  THR=THR, ylim=c(-1.5, 0.5), strict=F,
			  pch=21, col="grey60", cex=0.6,
			  xaxt="n")
		at <- pretty(range(position(lset)), 8)
		axis(1, at=at, labels=at/1e6)
		mtext(paste("offspring ", k , " of ", length(sns.list), sep=""), 3, outer=T)
	}
}
dev.off()
@
% Region1: why is k=4 selected? The overlap should be considered on
% the set of disjoint intervals


% Region2: Why is k=1 selected for region 2?  Why isn't this a deletion in mom?
% k = 2: why isn't this a deletion in dad?
<<debug>>=

@

% For the region on chr 17, the selected interval doesn't appear
% right.  is this a plotting artifact?  e.g., for k=32, this does not
% appear to be a disjoint interval.  k=32 might be an inherited CN
% polymorphism.  Look for a batch effect here...

Plot the biggest deletions in the offspring, irrespective of the
parent call.  Do any of these look real?  what are we missing?

<<bigDeletions>>=
bsSet <- checkExists("bsSet", .path=outdir, .FUN=load)
invisible(open(logR(bsSet)))
invisible(open(baf(bsSet)))
CHR <- 22
segmean_ranges <- getSegMeans(outdir, CHR=CHR)
i <- which(chromosome(bsSet) == CHR)
offspring.index <- which(who(segmean_ranges$id) == "offspring")
offspring.ranges <- segmean_ranges[offspring.index, ]
## the segmentation still includes WGA and samples with high mad.
offspring.ranges <- offspring.ranges[offspring.ranges$id %in% sampleNames(bsSet), ]
j <- which(who(sampleNames(bsSet)) == "offspring")
lset <- new("LogRatioSet",
	    logRRatio=as.matrix(logR(bsSet)[i, ]),
	    BAF=as.matrix(baf(bsSet)[i, ]),
	    featureData=featureData(bsSet)[i, ],
	    phenoData=phenoData(bsSet),
	    annotation=annotation(bsSet))
offspring.rule <- function(MAD) ifelse(-1.5*MAD < log(1.5/2), -1.5*MAD, log(1.5/2))
parent.rule <- function()  log(1.8/2)
is.deletion <- callDeletion(offspring.ranges, lset, parent.rule, offspring.rule)
offspring.ranges$is.deletion <- is.deletion
hist(width(offspring.ranges)[offspring.ranges$is.deletion], breaks=100)
deletion.ranges <- offspring.ranges[offspring.ranges$is.deletion, ]
index <- order(width(deletion.ranges), decreasing=TRUE)
deletion.ranges <- RangedData(IRanges(deletion.ranges$pos.start[index],
				      deletion.ranges$pos.end[index]),
			      index.start=start(deletion.ranges)[index],
			      index.end=end(deletion.ranges)[index],
			      num.mark=deletion.ranges$num.mark[index],
			      seg.mean=deletion.ranges$seg.mean[index],
			      id=deletion.ranges$id[index],
			      chrom=CHR)
##plot the top 50
for(i in 1:10){
	sns <- sampleNames(bsSet)[which(getFamily(bsSet) %in% substr(deletion.ranges$id[i], 1,5))]
	j <- match(sns, sampleNames(bsSet))
	marker.index <- which(chromosome(bsSet) == CHR)
	chrset <- new("LogRatioSet",
		      logRRatio=as.matrix(logR(bsSet)[marker.index, j]),
		      BAF=as.matrix(baf(bsSet)[marker.index, j]),
		      featureData=featureData(bsSet)[marker.index, ],
		      phenoData=phenoData(bsSet)[j, ],
		      annotation=annotation(bsSet))
 	k <- featuresInRange(chrset, deletion.ranges[i, ], FRAME=1e6)
	lset <- chrset[k, ]
	ids <- sampleNames(chrset)
	segmentation <- segmean_ranges[segmean_ranges$id %in% sampleNames(chrset), ]
	layout(matrix(1:6, 6,1), heights=c(1, 1, 1, 1, 1, 1, 0.25))
	par(mar=c(0.5, 0.5, 0.5, 0.5), las=1, oma=c(4, 4, 4, 4))
	father.name <- ids[who(ids) == "father"]
	mother.name <- ids[who(ids) == "mother"]
	offspring.name <- ids[who(ids) == "offspring"]
	plotRange(father.name, segmentation, lset, range=deletion.ranges[i, ],
		  THR=log(1.8/2), ylim=c(-1.5, 0.5),
		  pch=21, col="grey60", cex=0.6,
		  xaxt="n")
	plotRange(mother.name, segmentation, lset, range=deletion.ranges[i, ],
		  THR=log(1.8/2), ylim=c(-1.5,0.5),
		  pch=21, col="grey60", cex=0.6,
		  xaxt="n")
	THR <- offspring.rule(lset$MAD[match(offspring.name, sampleNames(lset))])
	plotRange(offspring.name, segmentation, lset, range=deletion.ranges[i, ],
		  THR=THR, ylim=c(-1.5, 0.5),
		  pch=21, col="grey60", cex=0.6,
		  xaxt="n")
	at <- pretty(range(position(lset)), 8)
	axis(1, at=at, labels=at/1e6)
}

##For each deletion.range with more than 10 markers, check whether there is 25% overlap or more with parents
query.rd <- deletion.ranges[1, ]
query <- IRanges(start(query.rd), end(query.rd))
ii <- which(!deletion.ranges$id %in% query.rd$id)
subject <- IRanges(start(deletion.ranges[ii, ]), end(deletion.ranges[ii, ]))
cnt <- countOverlaps(query, subject, minoverlap=width(query)/4)
@


