%\VignetteIndexEntry{Detection of de novo copy number alterations in case-parent trios}
%\VignetteDepends{?}
%\VignetteKeywords{MinimumDistance, copy number, SNP, case-parent trios, de novo}
%\VignettePackage{MinimumDistance}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{url}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\R}{\textsf{R}}
\newcommand{\md}{\Rpackage{MinimumDistance}}
\newcommand{\md}{\Rpackage{MinimumDistance}}
\newcommand{\logRratio}{$\log_2$ R ratio}
\newcommand{\baf}{B allele frequency}
\newcommand{\bafs}{B allele frequencies}
\newcommand{\tsl}{trioSetList}
\newcommand{\ts}{trioSet object}
\usepackage[margin=1in]{geometry}


\begin{document}
\title{Detection of de novo copy number alterations in case-parent
  trios using the \R{} package \md{}}
\date{\today}

\author{Moiz Bootwalla and Rob Scharpf}
\maketitle


<<setup, echo=FALSE, results=hide>>=
options(prompt="R> ", continue=" ", device=pdf, width=68)
@

\begin{abstract}

  This vignette provides an example of computing the minimum distance
  using the \R{} package \md{} which is used to detect de novo copy
  number alterations in case-parent trios from HapMap Phase 2 Data.

\end{abstract}

\section{Exemplar dataset}

This package requires the following data objects:
\begin{itemize}
  \item a \tsl{}, each element of which is a \ts{}. Apart from the
    regular slots in an \Rclass{eSet} object a \ts{} has slots for
    \logRratio{}s, \bafs{} and minimum distance. Both the
    \logRratio{}s and \bafs{} are organized as three dimensional
    arrays; the dimensions of which are number of markers X number of
    trios X 3 (the members in a trio i.e. Father, Mother and Offspring)
  \item a pedigree file, each row of which contains the pedigree
    information of the samples that make up a trio.
  \item a samplesheet file which contains information on gender, DNA
    source, chemistry plate, etc. This file must contain a \textbf{Sample.Name} column.
  \item \ldots
\end{itemize}

An example of each of these files is provided with the \R{} package
\md{}. The instructions below show how to initialize a \tsl{} using a
pedigree file and a samplesheet file. We first create phenodata and
feature data for the trios and then create \logRratio{} and \baf{}
arrays. Finally, we combine all of the above objects into a \ts{} for
one chromosome. Each \ts{} is stored as an element in a list and once
\ts{}s for all 22 chromosomes are created the list is saved as a
\tsl{}. Once an empty \tsl{} is initialized the \logRratio{}s and
\bafs{} can be filled in from the processed data files using the
appropriate accessors such as \Rcode{logR(trioSetList[[chromosome]])}
and \Rcode{baf(trioSetList[[chromosome]])}. 

<<exampleFile>>=
library(MinimumDistance)
data(pedigreeExample)
data(samplesheetExample)

stopifnot("Sample.Name" %in% colnames(samplesheetExample))
cdfName <- "human610quadv1b"

## Set up the feature data
fD <- oligoClasses:::featureDataFrom(paste(cdfName, "Crlmm", sep=""))
fD <- fD[order(fD$chromosome, fD$position), ]

## Set up the pheno data
ss <- array(NA, dim=c(nrow(pedigreeExample), ncol(samplesheetExample), 3),
		    dimnames=list(rownames(pedigreeExample),
		    colnames(samplesheetExample),
		    c("F", "M", "O")))
father.index <- match(substring(pedigreeExample[, "F"],3,7), 
		      substring(samplesheetExample$Sample.Name,6,10))
mother.index <- match(substring(pedigreeExample[, "M"],3,7), 
		      substring(samplesheetExample$Sample.Name,6,10))
offspring.index <- match(substring(pedigreeExample[, "O"],3,7), 
			 substring(samplesheetExample$Sample.Name,6,10))
ss[, , "F"] <- as.matrix(samplesheetExample[father.index, ])
ss[, , "M"] <- as.matrix(samplesheetExample[mother.index, ])
ss[, , "O"] <- as.matrix(samplesheetExample[offspring.index, ])
rownames(ss) <- pedigreeExample[, "O"]

## Create an array of BAF and logR ratios for each chromosome
marker.list <- split(sampleNames(fD), fD$chromosome)
marker.list <- marker.list[-(23:25)]
np <- nrow(pedigreeExample)
trioSetList <- vector("list", 22)
names(trioSetList) <- 1:22
for(chrom in seq_along(marker.list)){
	## Use the name of the offspring as the name for the trio:
	nr <- length(marker.list[[chrom]])
	bafArray <- logRArray <- array(NA, dim=c(nr, np, 3))
	dimnames(bafArray) <- dimnames(logRArray) <- list(marker.list[[chrom]],
								    as.character(pedigreeExample[, "O"]),
								    c("F", "M", "O"))
	## For each chromosome, create a TrioSet
	pD <- annotatedDataFrameFrom(as.matrix(logRArray[, , 1]), byrow=FALSE)
	sampleNames(pD) <- colnames(logRArray)
	index <- match(marker.list[[chrom]], sampleNames(fD))
	## initialize 'TrioSet'
	trioSetList[[chrom]] <- new("TrioSet",
				    logRRatio=logRArray,
				    BAF=bafArray,
				    phenoData=pD,
				    featureData=fD[index,],
				    mindist=NULL,
				    annotation=cdfName)
	stopifnot(validObject(trioSetList[[chrom]]))
	trioSetList[[chrom]]@phenoData2 <- ss
}
trioSetList <- as(trioSetList, "TrioSetList")
stopifnot(validObject(trioSetList))
@

You'll need the physical position and chromosome info.  The annotation
packages should be available from BioConductor. Here's how you can see
what annotation packages are available.  (You'll want to include this
in the vignette since other people may have different platforms).  The
R function minimumDistance initializes an object of class
'TrioSetList' and automatically provides annotation of chromosome and
physical position provided that the 'cdfname' for the package is
provided and an annotation package is available.

<<>>=
library(oligoClasses)
all.pkgs <- annotationPackages()
@

<<>>=
load("~mbootwal/packages/MinimumDistance/data/trioSet-hapmap.rda")
##
library(MinimumDistance)
trioSetList <- minimumDistance(container=trioSetList, readFiles=FALSE, calculate.md=TRUE,
		       container.filename="~/trioSetList.rda")
##mads <- matrix(NA, ncol(trioSetList[[1]]), 3)
##colnames(mads) <- c("F", "M", "O")
##rownames(mads) <- sampleNames(trioSetList[[1]])
#### need to calculate mad
##fff <- function(object, trio.index){
##	lR <- logR(object)[, trio.index, ]
##}
any(is.na(mad(trioSetList[[1]])))
any(is.na(mad(trioSetList[[22]])))
##for(j in seq(length=length(rownames(mads)))){
##	logrs <- do.call("rbind", sapply(trioSetList, fff, trio.index=j))
##	mads[j, ] <- apply(logrs, 2, mad, na.rm=TRUE)
##}
##for(k in seq(length=length(trioSetList))){
##	mad(trioSetList[[k]]) <- mads
##}
##trace(MinimumDistance:::computeLoglik, browser)
unlink("~/results.rda")
rd <- minimumDistanceCalls(container=trioSetList, chromosomes=1:5, cbs.filename="~/results.rda")
@


\section{Detection of de novo copy number}

The detection of de novo copy number is divided into 3
parts. Segmentation, Estimating posterior probabilities of trio copy
number states and Visualization. 

\subsection{Segmentation}

This part consists of computing the minimum distance and carrying out
circular binary segmentation of the minimum distance and logR ratios.

<<segmentation>>=
## computing the minimum distance
trioSetList <- minimumDistance(container=trioSetList,
                               chromosomes=1:22,
			       readFiles=FALSE,
                               cdfName="human610quadv1b",
                               calculate.md=TRUE,
                               calculate.mad=TRUE)

## segmentation of minimum distances and logR ratios
md.segs <- xsegment(object=trioSetList,
                    verbose=TRUE)
cbs.segs <- xsegment(object=trioSetList,
                     segment.mindist=FALSE,
                     verbose=TRUE)
@


\subsection{Posterior probabilities of trio copy number states}

The next part consists of estimating the maximum a posteriori
probabilities for each minimum distance segment. This allows the
inference of trio copy number states. States 1,2 represent a deletion,
State 3 represents normal copy number and States 4,5 represent an
amplification. Hence a trio copy number state of 335 means father and
mother are normal and offspring has an amplification.

<<minimumDistanceCalls>>=
called.ranges <- minimumDistanceCalls(container=trioSetList,
                                      cbs.segs=cbs.segs,
                                      ranges=md.segs,
                                      mindistance.threshold=0.09)
@ 

\subsection{Visualizations}

Plot the MAD log R ratio by chemistry plate

Plot the MAD log R ratio by DNA source

Plot the low-level summaries along with the minimum distance. Right
now, the function is called \Rfunction{minimumDistancePlot}.

'Rectangle' plots as in the paper (here, we'd only have de novo
predictions from 5 offspring)



\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@

\end{document}
