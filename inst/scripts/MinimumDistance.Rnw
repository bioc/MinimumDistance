%\VignetteIndexEntry{Detection of de novo copy number alterations in case-parent trios}
%\VignetteDepends{?}
%\VignetteKeywords{MinimumDistance, copy number, SNP, case-parent trios, de novo}
%\VignettePackage{MinimumDistance}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{url}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\R}{\textsf{R}}
\newcommand{\md}{\Rpackage{MinimumDistance}}
\newcommand{\logRratio}{$\log_2$ R ratio}
\newcommand{\baf}{B allele frequency}
\newcommand{\bafs}{B allele frequencies}
\newcommand{\tsl}{trioSetList}
\newcommand{\ts}{trioSet object}
\usepackage[margin=1in]{geometry}


\begin{document}
\title{Detection of de novo copy number alterations in case-parent
  trios using the \R{} package \md{}}
\date{\today}

\author{Moiz Bootwalla and Rob Scharpf}
\maketitle


<<setup, echo=FALSE, results=hide>>=
options(prompt="R> ", continue=" ", device=pdf, width=68)
@

\begin{abstract}

  This vignette provides an example of computing the minimum distance
  using the \R{} package \md{} which is used to detect de novo copy
  number alterations in case-parent trios from HapMap Phase 2 Data.

\end{abstract}

\section{Exemplar dataset}

This package requires the following data objects:
\begin{itemize}
  \item a \tsl{}, each element of which is a \ts{}. Apart from the
    regular slots in an \Rclass{eSet} object a \ts{} has slots for
    \logRratio{}s, \bafs{} and minimum distance. Both the
    \logRratio{}s and \bafs{} are organized as three dimensional
    arrays; the dimensions of which are number of markers X number of
    trios X 3 (the members in a trio i.e. Father, Mother and Offspring)
  \item a pedigree file, each row of which contains the pedigree
    information of the samples that make up a trio.
  \item a samplesheet file which contains information on gender, DNA
    source, chemistry plate, etc. This file must contain a \textbf{Sample.Name} column.
\end{itemize}

An example of each of these files is provided with the \R{} package
\md{}. The instructions below show how to initialize a \tsl{} using a
pedigree file and a samplesheet file. We first create phenodata and
feature data for the trios and then create \logRratio{} and \baf{}
arrays. Finally, we combine all of the above objects into a \ts{} for
one chromosome. Each \ts{} is stored as an element in a list and once
\ts{}s for all 22 autosomal chromosomes are created the list is saved
as a \tsl{}. Once an empty \tsl{} is initialized the \logRratio{}s and
\bafs{} can be filled in from the processed data files using the
appropriate accessors such as \Rcode{logR(trioSetList[[chromosome]])}
and \Rcode{baf(trioSetList[[chromosome]])}.

<<exampleFile>>=
library(MinimumDistance)
library(human610quadv1bCrlmm)
data(pedigreeExample)
rownames(pedigreeExample) <- NULL  ## no longer necessary to have rownames
data(samplesheetExample)
sample.sheet <- SampleSheet(filename=samplesheetExample$Sample.Name,
			    id=paste("NA",substr(samplesheetExample$Sample.Name, 6, 10),sep=""),
			    plate=samplesheetExample$Plate,
			    well=samplesheetExample$Well,
			    gender=samplesheetExample$Gender,
			    SentrixPosition=samplesheetExample$SentrixPosition)
##pedigreeTrios <- ##as(pedigreeExample, "Pedigree")
##pedigreeTrios <- as.matrix(pedigreeExample)
indId <- unlist(pedigreeExample)
trioFactor <- matrix(seq_len(nrow(pedigreeTrios)), nrow(pedigreeTrios), 3, byrow=FALSE)
memberId <- substr(names(indId), 1, 1)
## which row in the pedigree file
trio.index <- as.integer(trioFactor) ## note this gives the index in the pedigree
pedigreeIndex <- data.frame(individualId=indId,
			    memberId=memberId,
			    index.in.pedigree=trio.index,
			    stringsAsFactors=FALSE)
rownames(pedigreeIndex) <- NULL
pedigreeData <- new("Pedigree", trios=pedigreeExample,
		    trioIndex=pedigreeIndex)
show(pedigreeData)
data(logRArray)
data(bafArray)
## replace phenoDataArray with a coercion from TrioAnnotation to an array
## The coercion takes place in the 'TrioSetList' constructor
##trace(TrioSetList, browser)
##tmp <- new("TrioSetList", pedigree=pedigree, sampleSheet=sample.sheet)
##trace(TrioSetList, browser)
trioSetList <- TrioSetList(logR=logR,
			   baf=baf,
			   pedigree=pedigreeData,
			   sampleSheet=sample.sheet,
			   cdfname="human610quadv1bCrlmm")
trioSetList
sampleSheet(trioSetList)
pedigree(trioSetList)
trioSetList[1:5]
trioSetList[[1]]
## Note
identical(sampleNames(trioSetList), offspringNames(trioSetList))
@

In the above code feature annotation such as chromosome and position
for each snp is automatically done by the \Rcode{constructTrioSetList}
function since an annotation package name supported by
\Rpackage{crlmm} is provided in the function call. If the user uses an
annotation package not supported by \Rpackage{crlmm} then they must
provide feature annotation in the \Rcode{fD} option in the call to
\Rcode{constructTrioSetList}. Annotation packages supported by
\Rpackage{crlmm} can be viewed as follows:

<<>>=
library(oligoClasses)
annotationPackages()[grep("Crlmm", annotationPackages())]
@

\section{Detection of de novo copy number}

The detection of de novo copy number is divided into 3
parts. Segmentation, Estimating posterior probabilities of trio copy
number states and Visualization.

\subsection{Segmentation}

This part consists of computing the minimum distance and carrying out
circular binary segmentation of the minimum distance and logR ratios.

<<computeMinimumDistance,echo=FALSE>>=
## computing the MAD of the log R ratios for each individual.
mads.lrr <- calculateMADlrr(trioSetList)
## adds identical mad to each TrioSet element ... inefficient
mad(trioSetList) <- mads.lrr
md <- calculateMindist(object=trioSetList)
## calculate the mad of the minimum distance
mads.md <- lapply(md, function(x) apply(x, 2, mad, na.rm=TRUE))
## Add the mads of the minimum distance to the container
minimumDistanceMad(trioSetList) <- mads.md

## add the minimumDistance to the container.
mindist(trioSetList) <- md
## Alternatively,
##trioSetList <- minimumDistance(trioSetList)
@

Segment the minimum distance and return a \Robject{RangedDataCBS} object.

<<segmentMinimumDistance>>=
md.segs <- xsegment(object=trioSetList, segment.mindist=TRUE, verbose=TRUE)
md.segs
@

Segment the log R ratios of the offspring and return a
\Robject{RangedDataCBS} object.

<<segmentLRR>>=
lrr.segs <- xsegment(object=trioSetList, segment.mindist=FALSE,
		     id=sampleNames(trioSetList),
		     verbose=TRUE)
@

Narrow the minimum distance ranges.

<<narrow>>=
md.segs2 <- narrow(md.segs, lrr.segs, thr=0.1)
@

One can optionally prune the ranges.

<<prune, eval=FALSE>>=
@


<<computeBayesFactor>>=
tau <- MinimumDistance:::transitionProbability(states=0:4, epsilon=0.5)
log.pi <- log(MinimumDistance:::initialStateProbs(states=0:4, epsilon=0.5))
message("Computing bayes factors")
##md.segs2$state <- NA
object <- MinimumDistance:::computeBayesFactor(object=trioSetList[[1]],
			     ranges=md.segs2,
			     tau=tau,
			     log.pi=log.pi,
			     prOutlier=c(0.01, 1e-6),
			     prMosaic=0.01,
			     prob.nonMendelian=1.5e-6,
			     mu.logr=c(-2, -0.5, 0, 0.3, 0.75),
			     baf.sds=c(0.02, 0.03, 0.02),
			     returnEmission=FALSE)

object <- MinimumDistance:::computeBayesFactor(object=trioSetList,
			     ranges=md.segs2,
			     tau=tau,
			     log.pi=log.pi,
			     prOutlier=c(0.01, 1e-6),
			     prMosaic=0.01,
			     prob.nonMendelian=1.5e-6,
			     mu.logr=c(-2, -0.5, 0, 0.3, 0.75),
			     baf.sds=c(0.02, 0.03, 0.02),
			     returnEmission=FALSE)
@

\subsection{Posterior probabilities of trio copy number states}

The next part consists of estimating the maximum a posteriori
probabilities for each minimum distance segment. This allows the
inference of trio copy number states. States 1,2 represent a deletion,
State 3 represents normal copy number and States 4,5 represent an
amplification. Hence a trio copy number state of 335 means father and
mother are normal and offspring has an amplification.

<<minimumDistanceCalls>>=
called.ranges <- minimumDistanceCalls(container=trioSetList,
                                      cbs.segs=cbs.segs,
                                      ranges=md.segs,
                                      mindistance.threshold=0.09)
@

\subsection{Visualizations}

Plot the MAD log R ratio by chemistry plate

Plot the MAD log R ratio by DNA source

Plot the low-level summaries along with the minimum distance. Right
now, the function is called \Rfunction{minimumDistancePlot}.

'Rectangle' plots as in the paper (here, we'd only have de novo
predictions from 5 offspring)



\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@

\end{document}
