<<>>=
library(Beaty)
fns <- list.files("~/Projects/Beaty/inst/extdata", full.names=TRUE)
fn <- fns[grep("HS0", fns)]
trace(Beaty:::readMultiplexData, browser)
multiplex <- readMultiplexData(fn)

## Look at the mean Ct values across all wells for target sample and reference
## Why not assume that the median Ct should be the same.
plt3 <- names(table(multiplex$plate))[3]
index <- which(multiplex$plate == plt3)
boxplot(list(multiplex[index, "FAM.Ct"], multiplex[index, "VIC.Ct"]))

## HS01502562, HS02102421, and HS01512766 we did not have a calibrator sample.
# HS04085807 and HS02053540 we used 1341-01 as a calibrator sample
## Assay HS04504215 we used 1408-12 which again is a sample we had in the lab.
calibrator <- c(rep(TRUE, 3), rep(FALSE, 3))
names(calibrator) <- c("HS01502562", "HS02102421", "HS01512766",
		       "HS04085807", "HS02053540",
		       "HS045004215")
names(calibrator) <- paste(names(calibrator), ".txt", sep="")

Ct <- c(multiplex$FAM.Ct, multiplex$VIC.Ct)
sample <- rep(c("FAM", "VIC"), each=nrow(multiplex))
plt <- rep(multiplex$plate, 2)
ix <- match(plt, names(calibrator))
cal <- calibrator[ix]
stopifnot(all.equal(names(cal), plt))
dat <- data.frame(plate=plt, sample=sample, Ct=Ct, calibrator=cal)
##dat$plate <- factor(dat$plate, levels=unique(dat$plate), ordered=TRUE)
##dat$sample <- factor(dat$sample, levels=c("target", "reference"), ordered=TRUE)

library(lattice)
pdf("multiplexCt.pdf")
bwplot(Ct~sample|plate, data=dat)
dev.off()
@

<<>>=
fd <- Beaty:::probeCoordinates()
rownames(fd) <- paste(fd$probeids, ".txt",sep="")
fd <- fd[rownames(fd) %in% multiplex$plate, ]
##uid <- unique(multiplex$probeid, na.rm=TRUE)
##fd <- fd[fd$probeid %in% uid, ]
multiplex$start <- fd$st[match(multiplex$plate, rownames(fd))]
multiplex$end <- fd$en[match(multiplex$plate, rownames(fd))]
trace(Beaty:::mapTaqmanSampleIds, browser)
multiplex <- mapTaqmanSampleIds(multiplex)


library(RColorBrewer)
ix <- which(ss(penn.offspring$id)=="17013" & penn.offspring$chrom==4 & isDenovo(penn.offspring$state))
index <- ix[1]
panelLabels <- c("father", "mother", "offspring")
frame <- 3e6
f1a <- xyplot(r ~ x | id, trioSets, range=penn.offspring[index, ],
	     panelLabels=panelLabels,
	     layout=c(1,3), index.cond=list(3:1), frame=frame,
	     md.segs=mdRanges, ylim=c(-2.5, 2),
	     par.settings=list(plot.symbol=list(pch=21, cex=0.2, col="grey50"),
	                       par.xlab.text=list(cex=0.8),
	                       par.ylab.text=list(cex=0.8)),
	     xlab="",
	     ylab="log R ratio",
	     scales=list(x=list(tick.number=10, cex=0.5, tck=c(1,0), axs="i"),
	                 alternating=rep(1,3),
	                 y=list(cex=0.5)),
	     par.strip.text=list(lines=0.8, cex=0.7),
	     segments=FALSE)


## make plot for positive controls
##multiplex$seg.mean <- 2*2^(multiplex$seg.mean) ## put on same scale
save(multiplex, file="~/Papers/2011/CleftCnv/data/multiplex.rda")
df <- multiplex[!is.na(multiplex$family) & !is.na(multiplex$triostate), ]
df <- df[df$triostate==332, ]
xyplot(CN.Calculated~seg.mean | probeid + family,
       df[df$triostate==332, ],
       panel=function(x,y, probeid, sampleid, familyid, ..., subscripts){
	       print(subscripts)
	       panel.grid(h=5,v=5)
	       panel.xyplot(x, y, pch=21, cex=2.5, col="grey", ...)
	       subs <- function(x) substr(x, 7, 8)
	       ids <- sampleid[subscripts]
	       F <- which(subs(ids) == "03")
	       M <- which(subs(ids) == "02")
	       O <- which(subs(ids) == "01")
	       if(length(F) > 0){
		       panel.points(x[F], y[F], pch="F", col="black", cex=1.2)
	       }
	       if(length(M) > 0){
		       panel.points(x[M], y[M], pch="M", col="black", cex=1.2)
	       }
	       if(length(O) > 0){
		       panel.points(x[O], y[O], pch="O", col="black", cex=1.2)
	       }
	       sampleid[subscripts]
       }, probeid=df$probeid, sampleid=df$sampleid,
       familyid=df$family,
       par.strip.text=list(cex=0.6),
       xlab="segment mean from CBS",
       ylab="TaqMan estimate", main="De novo hemizygous deletions predicted from high-throughput platform")






## make the following data.frame
## start, end, gene name, probe id, sample id, trio call, trio call penn cnv, min distance, segment mean


##
## assayData matrices
## probeid x father (segment means)
## probeid x mother (segment means)
## probeid x offspring (segment means)
## probeid x father (multiplex est)
## probeid x mother (multiplex est)
## probeid x offspring (multiplex est)
##
##
plot(logRF(), logRF.multiplex(), pch=".")

##segment mean from mindist, mean of segment containing probe (FMO), multiplex estimate (FMO), trio call, trio call penncnv
@

% FAM/VIC CT Mean – The arithmetic mean of the CT that is calculated
% for the technical replicates of the associated sample, where the:
% FAM column displays the mean CT for the signal associated with the
% FAM dye-labeled probe of the copy number assay.  VIC column displays
% the mean CT for the signal associated with the VIC dye-labeled probe
% of the reference assay
%
% RQ (relative quantity): 2^-(DeltaDeltaC_T)
% DeltaDeltaC_T = mean(DeltaC_T)_target - mean(DeltaC_T)_calibrator
%
% cn estimate = RQ x cn_calibrator
<<>>=
library(lattice)
(fam <- xyplot(FAM.Ct~as.factor(probeid)|sampleid, df, scales=list(x=list(rot=90)), cex=0.6,
	      panel=function(x, y, ..., subscripts){
		      panel.grid(v=-length(unique(df$probeid)), h=0)
		      ##panel.grid(v=-1, h=0)
		      panel.xyplot(x, y, ...)
	      }))
(vic <- xyplot(VIC.Ct~as.factor(probeid)|sampleid, df, scales=list(x=list(rot=90)), cex=0.6,
	      panel=function(x, y, ..., subscripts){
		      panel.grid(v=-length(unique(df$probeid)), h=0)
		      ##panel.grid(v=-1, h=0)
		      panel.xyplot(x, y, ...)
	      }))
##What is NTC
deltafig <- xyplot(FAM.Ct-VIC.Ct~as.factor(sampleid)|probeid, multiplex, scales=list(x=list(rot=90)),cex=0.6,
		   panel=function(x, y, ..., subscripts){
			   panel.abline(h=0, col="blue")
			   panel.grid(v=-length(unique(df$probeid)), h=0)
			   ##panel.grid(v=-1, h=0)
			   panel.xyplot(x, y, ...)
		   })

deltafig2 <- xyplot(log2(FAM.Ct/VIC.Ct)~as.factor(sampleid)| as.factor(probeid), multiplex, scales=list(x=list(rot=90), y=list(relation="free")),cex=0.6,
		    panel=function(x, y, ..., subscripts){
			   panel.abline(h=0, col="blue")
			   panel.grid(v=-length(unique(df$probeid)), h=0)
			   panel.xyplot(x, y, ...)
		   })
@

<<multiplexfigs>>=
trellis.device("pdf", file="~/Projects/Beaty/figures/multiplex_%02d.pdf",
	       width=10, height=7)
pars <- trellis.par.get()
pars$axis.text$cex <- 0.6
pars$xlab.text$cex <- 0.8
pars$ylab.text$cex <- 0.8
trellis.par.set("axis.text", pars$axis.text)
trellis.par.set("xlab.text", pars$xlab.text)
trellis.par.set("ylab.text", pars$xlab.text)
print(fam)
print(vic)
print(deltafig)
print(deltafig2)
dev.off()
@

<<arrayFigs>>=
map <- read.csv("~/Projects/Beaty/inst/extdata/gwas_to_local_id.csv",as.is=TRUE)
load("~/Projects/BeatyExperimentData/data/minDistanceSet.rda")

data(bsSet)
trioList <- initTrioList(bsSet, minDistanceSet)
df <- constructTrioSetFrom(ranged.data=range.pruned[2, ], trioList=trioList, FRAME=200e3)
df$logR <- ifelse(df$logR < -2.8, jitter(-2.8, amount=0.1), df$logR)
@

Copycaller software.

Theoretical model:

Delta_CT = K - log[1+E] * CN

1. estimate K -- the mean Delta_CT for copy number 1
2. calculate DeltaDelta_CT  using the estimate for K in place of the
calibrator sample
3. copy number = cn_c * 2^{-DeltaDelta_CT}

where cn_c is the copy number of the target sequence in the calibrator
sample.

4.  efficiency.  assumed to be 100%
5. K – Determined by maximizing the likelihood of the observed ΔCT
 replicate
means as a function of this parameter. The likelihood of the observations is
taken to be the sum of probability density across all samples for a given model.

<<>>=
df <- df[!is.na(df$probeid), ]
probes <- unique(df$probeid)
for(i in seq_along(probes)){
	df2 <- df[df$probeid == probes[i], ]
	tmp <- split(df2$Delta.Ct, df2$sampleid)
	mean.DeltaCT <- sapply(tmp, mean)
	K <- mean(mean.DeltaCT, na.rm=T)
}
mean.DeltaCT <- mean.DeltaCT[!is.na(mean.DeltaCT)]
plot(density(mean.DeltaCT))
@
