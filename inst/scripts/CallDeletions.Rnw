We add a \Robject{isDeletion} value column to the
\Robject{segmean\_ranges} object.  For each segment, we will make a
call (0 or 1) of whether the segment mean indicates a homozygous or
hemizygous deletion. (Later we may want to distinguish between
homozygous and hemizygous deletions.)  Note that the rule we use for
calling deletions is different for parents and offspring.

<<rules>>=
## more conservative
offspring.rule <- function(MAD) ifelse(-2*MAD < log(1.25/2), -2*MAD, log(1.25/2))
## very liberal
##parent.rule <- function(MAD) ifelse(-1.5*MAD < log(1.75/2), -1.5*MAD, log(1.75/2))
parent.rule <- function()  log(1.8/2)
@


With the above rules, we make a call of deletion (1=yes, 0=no) for
each segment.

<<callDeletion>>=
callDeletion <- function(segmeans, lset, parent.rule, offspring.rule){
	## call for parents
	is.deletion <- rep(NA, nrow(segmeans))
	index <- which(segmeans$pedId == "father" | segmeans$pedId == "mother")
	is.deletion[index] <- ifelse(segmeans$seg.mean[index] < parent.rule(), TRUE, FALSE)

	offspring.index <- which(segmeans$pedId == "offspring")
	offspring.ids <- segmeans$id[offspring.index]
	uids <- unique(offspring.ids)
	offspring.ids <- split(offspring.ids, offspring.ids)
	offspring.ids <- offspring.ids[match(uids, names(offspring.ids))]
	nn <- sapply(offspring.ids, length)

	##uids <- unique(segmeans$id[segmeans$pedId == "offspring"])
	mads <- lset$MAD
	names(mads) <- sampleNames(lset)
	mads <- mads[match(uids, names(mads))]
	stopifnot(identical(names(mads), uids))
	mads <- rep(mads, nn)
	thr <- offspring.rule(mads)
	is.deletion[offspring.index] <- ifelse(segmeans$seg.mean[offspring.index] < thr, TRUE, FALSE)
	return(is.deletion)
}
segmeans$is.deletion <- callDeletion(segmeans, lset, parent.rule, offspring.rule)
@

A few descriptive statistics.


\begin{figure}[tbh]
  \centering
<<numberDeletions_chr1, fig=TRUE, width=8, height=6>>=
dset <- segmeans[segmeans$pedId == "offspring", ]
dset$id <- as.character(dset$id)
freq.o <- sapply(split(dset$is.deletion, dset$id), function(x) sum(x == 1))
pset <- segmeans[segmeans$pedId == "mother" | segmeans$pedId == "father", ]
pset$id <- as.character(pset$id)
freq.p <- sapply(split(pset$is.deletion, pset$id), function(x) sum(x == 1))
par(mfrow=c(1, 2), las=1)
med.o <- median(freq.o)
freq.o[freq.o > 15] <- 15
hist(freq.o, xlim=c(0,15), breaks=40, main="offspring", xlab="number of deletions in chromosome 1", xaxt="n", col="lightblue")
axis(1, at=15, labels="15+")
axis(1, at=pretty(c(0, 14)), labels=pretty(c(0,14)))
abline(v=med.o, col="blue")

med.p <- median(freq.p)
freq.p[freq.p > 15] <- 15
hist(freq.p, xlim=c(0,25), breaks=40, main="parents", xlab="number of deletions in chromosome 1", xaxt="n", col="lightblue")
axis(1, at=15, labels="15+")
axis(1, at=pretty(c(0, 14)), labels=pretty(c(0,14)))
abline(v=median(freq.p), col="blue")
@
\caption{The frequency of a deletion event in offspring (left) and
  parents (right) for chromosome 1.  The distribution of called
  deletions in parents is greater than the distribution in offspring,
  largely because of the difference in the rule used to call
  variants. We used different calling rules in order to reduce the
  number of false positive deletions in the offspring and the number
  of false negative deletions in the parents. The 'typical' offspring
  has 2 deletions whereas the 'typical' parent has 3 deletions on
  chromosome 1.}
\end{figure}

\begin{figure}[tbh]
  \centering
<<typicalNumberMarkers_chr1, fig=TRUE, width=8, height=5>>=
par(mfrow=c(1,1), las=1)
## if not deleted in offspring, we do not need to check the parents
dset <- dset[dset$is.deletion==1, ]
w <- width(dset)##/1000
median.w <- median(w)
w[w > 25] <-  25
hist(w, breaks=200, xlab="number of markers in a deletion", main="", xaxt="n", col="lightblue")
axis(1, at=1:23, labels=1:23)
##axis(1, at=25, labels="25+")
##axis(1, at=pretty(c(0, 35)), labels=pretty(c(0,35)))
##axis(1, at=40, labels="40+")
####median.w <- round(median(log10(w)), 2)
##abline(v=median.w, col="blue")
##axis(1, at=median.w, labels=round(median.w, 2))
@
\caption{Distribution of deletion sizes. The median deletion size is
  \Sexpr{round(median.w, 2)} kb.}
\end{figure}

<<clean>>=
rm(dset); gc()
@
