
Plot the log R values for candidate regions in randomly selected trios
(though excluding the WGA samples for now).  Find out why some of the
parent names are missing in the pedigree file (index[5] below).  These
plots can be used to assess the rules we use for defining denovo
events.


<<excludeWgaSamples>>=
bsSet <- checkExists("bsSet", path=outdir)
open(baf(bsSet))
stopifnot(identical(featureNames(bsSet), featureNames(lrSet)))
##data(pedigree)
set.seed(123)
wga.sns <- sampleNames(lrSet)[grep("WGA", lrSet$DNA.Source)]
offspring_ranges$id <- as.character(offspring_ranges$id)
if(any(offspring_ranges$id %in% wga.sns)){
	offspring_ranges <- offspring_ranges[!offspring_ranges$id %in% wga.sns, ]
	denovo <- offspring_ranges$isDenovo
}
@

<<plotCandidates, eval=FALSE>>=
index <- which(denovo == 1 & offspring_ranges$num.mark > 5)##1913
index <- sample(index, 50)
abbrv.names <- substr(lrSet$Sample.Name, 1, 8)
offspring.id <- as.character(offspring_ranges$id)
or <- IRanges(start(offspring_ranges), end(offspring_ranges))
open(logR(lrSet))
use.pos <- TRUE  ##whether to use physical distance or marker index for x-axis
bitmap("sampledDenovo%02d.png", res=500)

for(i in seq_along(index)){
	cat(i, " " )
	ii <- index[i]
	oid <- offspring.id[ii]
	parent.id <- paste(substr(oid, 1, 5), c("02", "03"), sep="_")
	marker.index <- lrSet %b/w% offspring_ranges[ii, ]
	marker.index <- mybase:::window(marker.index, size=100)
	parent.index <- match(parent.id, substr(sampleNames(lrSet), 1,8))##pedigree$Sample.Name)
	sample.index <- c(match(oid, lrSet$Sample.Name), parent.index)
	lab <- toupper(substr(who(sampleNames(lrSet)[sample.index]), 1,1))
	stopifnot(length(sample.index) == 3)
	y <- as.matrix(logR(lrSet)[marker.index, sample.index])
	b <- as.matrix(baf(bsSet)[marker.index, sample.index])
	if(use.pos){
		pos <- position(lrSet)[marker.index]
	} else pos <- seq_along(marker.index)
	chr <- unique(chromosome(lrSet)[marker.index])
	ylim <- range(y, na.rm=TRUE)
	layout(matrix(1:6, 6,1), heights=c(1, 0.7, 1, 0.7, 1, 0.7))
	par(las=1, mar=c(0.5, 4, 0.5, 0.5), oma=c(4, 0.5, 3, 3))
	for(j in 1:3){
		plot(pos, y[, j], pch=21,
		     xaxt="n", ylab="log R ratio",
		     xlab="", ylim=ylim, col="blue", cex=0.7)##ylab="log R Ratio", xlab="", ylim=c(-4,3))
		mtext(lab[j], 4, line=1, col="blue", cex=1.2)
		if(j==1) abline(h=0, col="grey50")
		if(j==1){
			abline(v=c(start(or)[ii], end(or)[ii]), lty=2, col="blue")
		}
		plot(pos, b[, j], pch=21,
		     xaxt="n", ##ylab="BAF",
		     xlab="", ylab="", col="red", cex=0.7)
		mtext(lab[j], 4, line=1, col="blue", cex=1.2)
		if(j==3){
			at <- pretty(pos)
			if(use.pos) axis(side=1, at=at, labels=at/1e6, outer=FALSE, line=0)
			if(!use.pos) axis(side=1, at=at, labels=at, outer=FALSE, line=0)
		}
	}
	mtext(paste("Chr:", chr), 3, outer=TRUE)
}
dev.off()
q("no")
@

%-ADD B-allele FREQUENCY. FILTER by MAD.

%DENOVO rate.  not well described.  could estimate background frequency
%in unaffected offspring
%
%List of 300 genes involved in pathways related to cleft palate

Next we construct a RangedData object with disjoint intervals by
taking the union of all the start and end positions of the altered
regions.

<<disjointRanges, fig=TRUE>>=
or_rd <- offspring_ranges[offspring_ranges$isDenovo == 1, ]
##num.mark is incorrect -- all zeros
disjoint_rd <- disjointRanges(or_rd, featureData(lrSet), use.arm=FALSE)
par(mfrow=c(2,1), las=1, mar=c(4, 6, 4, 3))
hist(disjoint_rd$num.overlap, breaks=50, main="", ylab="", xlab="number of offspring with a called denovo event")
hist(disjoint_rd$num.mark, breaks=50, main="", ylab="")
@

4. Plot regions with a high frequency of denovo-events.

<<top10>>=
disjoint_rd <- disjoint_rd[order(disjoint_rd$num.overlap, disjoint_rd$num.mark, decreasing=TRUE), ]
altered.offspring_rd <- offspring_ranges[offspring_ranges$isDenovo==1, ]
snsList <- vector("list", 10)
top10_rd <- disjoint_rd[1:10, ]
for(i in 1:nrow(top10_rd)){
	CHR <- top10_rd$chrom[i]
	query <- IRanges(start(top10_rd)[i], end(top10_rd)[i])
	index <- which(altered.offspring_rd$chrom == CHR)
	subj <- IRanges(start(altered.offspring_rd)[index],
			end(altered.offspring_rd)[index])
	ids <- altered.offspring_rd$id[index]
	tmp <- findOverlaps(query, subj)
	indices <- matchMatrix(tmp)[,2]
	snsList[[i]] <- altered.offspring_rd$id[indices]
}
@

<<plotTop10>>=
## for each sample in the list, get the indices of the trio in the container for the CN estimates
sns <- unlist(snsList)
findTrioIndex <- function(sns, lrSet){
	ii <- match(sns, sampleNames(lrSet))
	fam <- lrSet$family[ii]
	grepfamily <- function(x, families) grep(x, families)
	trio.index <- t(sapply(fam, grepfamily, families=lrSet$family))
	return(trio.index)
}
trio.index <- lapply(snsList, findTrioIndex, lrSet=lrSet)
for(i in seq_along(snsList)){
	cat(i, " " )
	ii <- index[i]
	oid <- offspring.id[ii]
	parent.id <- paste(substr(oid, 1, 5), c("02", "03"), sep="_")
	marker.index <- lrSet %b/w% offspring_ranges[ii, ]
	marker.index <- mybase:::window(marker.index, size=100)
	parent.index <- match(parent.id, substr(sampleNames(lrSet), 1,8))##pedigree$Sample.Name)
	sample.index <- c(match(oid, lrSet$Sample.Name), parent.index)
	lab <- toupper(substr(who(sampleNames(lrSet)[sample.index]), 1,1))
	stopifnot(length(sample.index) == 3)
	y <- as.matrix(logR(lrSet)[marker.index, sample.index])
	b <- as.matrix(baf(bsSet)[marker.index, sample.index])
	if(use.pos){
		pos <- position(lrSet)[marker.index]
	} else pos <- seq_along(marker.index)
	chr <- unique(chromosome(lrSet)[marker.index])
	ylim <- range(y, na.rm=TRUE)
	layout(matrix(1:6, 6,1), heights=c(1, 0.7, 1, 0.7, 1, 0.7))
	par(las=1, mar=c(0.5, 4, 0.5, 0.5), oma=c(4, 0.5, 3, 3))
	for(j in 1:3){
		plot(pos, y[, j], pch=21,
		     xaxt="n", ylab="log R ratio",
		     xlab="", ylim=ylim, col="blue", cex=0.7)##ylab="log R Ratio", xlab="", ylim=c(-4,3))
		mtext(lab[j], 4, line=1, col="blue", cex=1.2)
		if(j==1) abline(h=0, col="grey50")
		if(j==1){
			abline(v=c(start(or)[ii], end(or)[ii]), lty=2, col="blue")
		}
		plot(pos, b[, j], pch=21,
		     xaxt="n", ##ylab="BAF",
		     xlab="", ylab="", col="red", cex=0.7)
		mtext(lab[j], 4, line=1, col="blue", cex=1.2)
		if(j==3){
			at <- pretty(pos)
			if(use.pos) axis(side=1, at=at, labels=at/1e6, outer=FALSE, line=0)
			if(!use.pos) axis(side=1, at=at, labels=at, outer=FALSE, line=0)
		}
	}
	mtext(paste("Chr:", chr), 3, outer=TRUE)
}
@
