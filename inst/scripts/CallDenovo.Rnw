Construct a queryList and a subjectList.  Each element in queryList
are the ranges for one offspring.  Each element in subjectList are the
ranges of the parents corresponding to the element in queryList.

<<queryList>>=
## the query list are the deletions found in the offspring
queryset <- segmeans[segmeans$pedId == "offspring" & segmeans$is.deletion, ]
query.list <- checkExists("query.list", .path=outdir, .FUN=split, x=queryset, f=queryset$id)#, .load.it=FALSE)
names(query.list) <- substr(names(query.list), 1, 5)

## among the regions that are deleted in the offspring (filter by family), check the parents
is.parent <- segmeans$pedId == "father" | segmeans$pedId == "mother"
family.in.query <- substr(segmeans$id, 1, 5) %in% names(query.list)
parent.ranges <- segmeans[is.parent & family.in.query, ]# & segmeans$is.deletion, ]
stopifnot(length(unique(parent.ranges$family)) == length(query.list))
subject.list <- checkExists("subject.list", .path=outdir, .FUN=split, x=parent.ranges, f=parent.ranges$family)#, .load.it=FALSE)
stopifnot(identical(names(query.list), names(subject.list)))
@

For each element in the query.list (the deletion ranges for one
offspring, one chromosome), count the overlap with the corresponding
element in subject.list (the deletion ranges for the mother and the
father of that offspring).  Deletions with zero overlap are denovo.
Deletions with 1 or more overlaps are inherited.

<<callDenovo>>=
##denovoList <- vector("list", length(query.list))
denovo.list <- checkExists("denovo.list", .path=outdir, .FUN=callDenovo, query.list=query.list, subject.list=subject.list)##, .load.it=F)
denovo.list <- as(denovo.list, "list")
## for each query, calculate the proportion of logR values in the parents that is below the threshold
denovoset <- checkExists("denovoset", .path=outdir, .FUN=pBelow,
			 denovo.list=denovo.list, lset=lset)
denovoset$is.denovo <- denovoset$number.overlap == 0 & denovoset$propLow.Father < 0.25 & denovoset$propLow.Mother < 0.25
@

Among \Sexpr{nrow(denovoset)} deletions in the offspring,
\Sexpr{sum(denovoset$is.denovo)} were denovo.


<<numberMarkers, fig=TRUE>>=
denovo.ranges <- denovoset[denovoset$is.denovo, ]
par(las=1)
hist(width(denovo.ranges), col="lightblue", breaks=50, xlab="number of markers",
     ylab="number of denovo events", xlim=c(0,40))
@


Construct the disjoint ranges and count the frequency.

<<findOverlaps>>=
overlapList <- myOverlaps(denovo.ranges)
disjoint.ranges <- overlapList[["disjoint.rd"]]
denovo.sns <- overlapList[["sns"]]
@

Interesting 'regions' will be separated by a range without any denovo
events. Consecutive disjoint ranges with a frequency greater than 1
demarcate a region of interest. Find the number of interesting
regions.

<<numberOfRegions>>=
freq <- disjoint.ranges$freq
region.factor <- cumsum(c(0, diff(freq > 0) !=0))
disjoint.ranges$region <- region.factor
## exclude disjoint ranges without a denovo event
region.factor <- region.factor[freq > 0]
@

There are \Sexpr{length(region.factor)} interesting regions.

\begin{figure}[tbh]
  \centering
<<widthVfreq, fig=TRUE, width=8, height=6>>=
x.start <- position(lset)[start(disjoint.ranges)]
x.end <- position(lset)[end(disjoint.ranges)]
x <- (x.end-x.start)/1e3
y <- disjoint.ranges$freq
x <- x[disjoint.ranges$freq > 0]
y <- y[disjoint.ranges$freq > 0]
x[x > 100] <- 100
plot(x, jitter(y, amount=0.1),
     xlab="size (kb) of disjoint range", pch=21, col="grey60", cex=0.6, xaxt="n", yaxt="n",
     ylab="offspring with denovo event",
     main=paste("chr", CHR))##, xlim=c(0, xmax+5), ylim=c(0,150))
axis(1, at=seq(0, 90, 10))
axis(1, at=100, labels="100+")
axis(2, at=1:3, labels=1:3)
@
\end{figure}

<<poissonForNull, eval=FALSE, echo=FALSE>>=
##axis(1, at=1, labels=1)
## estimate mu
library(Hmisc)
mycuts <- cut2(x=x, g=50)
xx <- split(x, mycuts)
yy <- split(disjoint.rd$freq, mycuts)

xx.mean <- sapply(xx, mean)
lambdas <- sapply(yy, mean)
qtl <- qpois(p=0.99, lambda=lambdas)
sm.qtl <- runmed(qtl, 3)
lines(xx.mean, sm.qtl, lwd=2)
abline(v=5, lwd=2)
axis(1, at=5, labels=5)
## which frequencies are greather than the smoothed poisson quantile
index1 <- list()
for(i in seq_along(yy)){
	index1[[i]] <- yy[[i]] > sm.qtl[i]
}
index1 <- unlist(index1)
bg <- brewer.pal(4, "Accent")[1]
index2 <- unlist(xx) > 5
index <- which(index2 & index1)
points(unlist(xx)[index], unlist(yy)[index], bg=bg, pch=21)
orig.index <- unlist(split(seq_along(x), mycuts))[index]
@

Extract the lower level data: log R ratios and B allele frequencies.
Make a plot for each trio involved.  Think of a more efficient data
summary, perhaps using image and shading proportional to the segment
mean.  Plot the region for an individual with a denovo event.



How often would we expect to find such a region by chance?  - regions
near centromere and telomeres are more unstable (need to take
instability into account when simulating a null) - do we think common
cnv variants contribute to the phenotype?  - for the hotspots, what
type of cleft palate disorder do the affected offspring have?









